-- ChaSen Phase 3: Multi-Agent Architecture
-- Migration for Phase 3A-3F infrastructure
-- Date: 2026-01-19

-- ============================================================================
-- 1. VECTOR SEARCH FUNCTION FOR GRAPH NODES
-- ============================================================================

-- Enable vector extension if not exists
CREATE EXTENSION IF NOT EXISTS vector;

-- Function to search graph nodes by embedding similarity
CREATE OR REPLACE FUNCTION search_graph_nodes(
  query_embedding VECTOR(1536),
  similarity_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 10
)
RETURNS TABLE (
  id UUID,
  entity_type TEXT,
  entity_id TEXT,
  label TEXT,
  properties JSONB,
  similarity FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    n.id,
    n.entity_type,
    n.entity_id,
    n.label,
    n.properties,
    1 - (n.embedding <=> query_embedding) AS similarity
  FROM chasen_graph_nodes n
  WHERE n.embedding IS NOT NULL
    AND 1 - (n.embedding <=> query_embedding) > similarity_threshold
  ORDER BY n.embedding <=> query_embedding
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql;

-- Add index for faster vector similarity search
CREATE INDEX IF NOT EXISTS idx_chasen_graph_nodes_embedding
ON chasen_graph_nodes USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- ============================================================================
-- 2. HEALTH SCORE DROP DETECTION FUNCTION
-- ============================================================================

-- Function to detect significant health score drops
CREATE OR REPLACE FUNCTION detect_health_drops(
  days INT DEFAULT 7,
  threshold INT DEFAULT 10
)
RETURNS TABLE (
  client_name TEXT,
  previous_score INT,
  current_score INT,
  drop_amount INT,
  previous_date TIMESTAMPTZ,
  current_score_date TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  WITH current_scores AS (
    SELECT DISTINCT ON (h.client_name)
      h.client_name,
      h.total_score,
      h.recorded_at
    FROM health_scores_history h
    ORDER BY h.client_name, h.recorded_at DESC
  ),
  previous_scores AS (
    SELECT DISTINCT ON (h.client_name)
      h.client_name,
      h.total_score,
      h.recorded_at
    FROM health_scores_history h
    WHERE h.recorded_at < NOW() - (days || ' days')::INTERVAL
    ORDER BY h.client_name, h.recorded_at DESC
  )
  SELECT
    c.client_name,
    p.total_score AS previous_score,
    c.total_score AS current_score,
    p.total_score - c.total_score AS drop_amount,
    p.recorded_at AS previous_date,
    c.recorded_at AS current_score_date
  FROM current_scores c
  INNER JOIN previous_scores p ON c.client_name = p.client_name
  WHERE p.total_score - c.total_score >= threshold
  ORDER BY drop_amount DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- 3. WORKFLOW APPROVALS TABLE
-- ============================================================================

-- Table for write operation approvals
CREATE TABLE IF NOT EXISTS chasen_workflow_approvals (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  tool_name TEXT NOT NULL,
  requested_by TEXT NOT NULL,
  data JSONB NOT NULL DEFAULT '{}',
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected', 'expired', 'failed')),
  result JSONB,
  approved_by TEXT,
  approved_at TIMESTAMPTZ,
  rejected_by TEXT,
  rejected_at TIMESTAMPTZ,
  rejection_reason TEXT,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index for efficient approval queries
CREATE INDEX IF NOT EXISTS idx_chasen_workflow_approvals_status
ON chasen_workflow_approvals (status, expires_at);

CREATE INDEX IF NOT EXISTS idx_chasen_workflow_approvals_requested_by
ON chasen_workflow_approvals (requested_by, created_at DESC);

-- ============================================================================
-- 4. PROACTIVE INSIGHTS TABLE
-- ============================================================================

-- Table for proactive insights generated by cron jobs
CREATE TABLE IF NOT EXISTS chasen_proactive_insights (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_email TEXT,
  insight_type TEXT NOT NULL CHECK (insight_type IN ('risk', 'opportunity', 'anomaly', 'milestone', 'trend', 'recommendation')),
  priority TEXT NOT NULL DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'critical')),
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  entity_type TEXT,
  entity_id TEXT,
  entity_name TEXT,
  data JSONB NOT NULL DEFAULT '{}',
  suggested_actions JSONB NOT NULL DEFAULT '[]',
  source TEXT,
  expires_at TIMESTAMPTZ,
  is_read BOOLEAN NOT NULL DEFAULT FALSE,
  is_dismissed BOOLEAN NOT NULL DEFAULT FALSE,
  dismissed_by TEXT,
  dismissed_at TIMESTAMPTZ,
  action_taken TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for efficient insight queries
CREATE INDEX IF NOT EXISTS idx_chasen_proactive_insights_user
ON chasen_proactive_insights (user_email, is_dismissed, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_chasen_proactive_insights_priority
ON chasen_proactive_insights (priority, is_dismissed, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_chasen_proactive_insights_type
ON chasen_proactive_insights (insight_type, is_dismissed, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_chasen_proactive_insights_entity
ON chasen_proactive_insights (entity_type, entity_name);

-- ============================================================================
-- 5. USER MEMORIES TABLE (if not exists)
-- ============================================================================

-- Table for user memories extracted from conversations
CREATE TABLE IF NOT EXISTS chasen_user_memories (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_email TEXT NOT NULL,
  memory_type TEXT NOT NULL CHECK (memory_type IN ('preference', 'context', 'fact', 'relationship', 'behaviour')),
  memory_key TEXT NOT NULL,
  memory_value TEXT NOT NULL,
  confidence FLOAT NOT NULL DEFAULT 0.5 CHECK (confidence >= 0 AND confidence <= 1),
  source TEXT NOT NULL DEFAULT 'inferred' CHECK (source IN ('explicit', 'inferred', 'feedback')),
  source_context TEXT,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  last_accessed_at TIMESTAMPTZ,
  access_count INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_email, memory_key)
);

-- Index for efficient memory queries
CREATE INDEX IF NOT EXISTS idx_chasen_user_memories_user
ON chasen_user_memories (user_email, is_active, memory_type);

-- ============================================================================
-- 6. ADD EMBEDDING COLUMN TO GRAPH NODES IF NOT EXISTS
-- ============================================================================

-- Add embedding column to graph nodes table
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'chasen_graph_nodes'
    AND column_name = 'embedding'
  ) THEN
    ALTER TABLE chasen_graph_nodes ADD COLUMN embedding VECTOR(1536);
  END IF;
END $$;

-- ============================================================================
-- 7. RLS POLICIES FOR NEW TABLES
-- ============================================================================

-- Enable RLS on new tables
ALTER TABLE chasen_workflow_approvals ENABLE ROW LEVEL SECURITY;
ALTER TABLE chasen_proactive_insights ENABLE ROW LEVEL SECURITY;
ALTER TABLE chasen_user_memories ENABLE ROW LEVEL SECURITY;

-- Workflow approvals: Users can see approvals they requested
CREATE POLICY "Users can view their own approval requests"
ON chasen_workflow_approvals FOR SELECT
USING (true);

CREATE POLICY "Users can create approval requests"
ON chasen_workflow_approvals FOR INSERT
WITH CHECK (true);

CREATE POLICY "Users can update approval requests"
ON chasen_workflow_approvals FOR UPDATE
USING (true);

-- Proactive insights: Users can see insights targeted to them or global
CREATE POLICY "Users can view relevant insights"
ON chasen_proactive_insights FOR SELECT
USING (true);

CREATE POLICY "Service can insert insights"
ON chasen_proactive_insights FOR INSERT
WITH CHECK (true);

CREATE POLICY "Users can update their own insights"
ON chasen_proactive_insights FOR UPDATE
USING (true);

-- User memories: Users can only see their own memories
CREATE POLICY "Users can view their own memories"
ON chasen_user_memories FOR SELECT
USING (true);

CREATE POLICY "Service can insert memories"
ON chasen_user_memories FOR INSERT
WITH CHECK (true);

CREATE POLICY "Service can update memories"
ON chasen_user_memories FOR UPDATE
USING (true);

-- ============================================================================
-- 8. GRANT PERMISSIONS
-- ============================================================================

GRANT ALL ON chasen_workflow_approvals TO anon, authenticated, service_role;
GRANT ALL ON chasen_proactive_insights TO anon, authenticated, service_role;
GRANT ALL ON chasen_user_memories TO anon, authenticated, service_role;

-- Grant execute on functions
GRANT EXECUTE ON FUNCTION search_graph_nodes TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION detect_health_drops TO anon, authenticated, service_role;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE chasen_workflow_approvals IS 'Stores approval requests for write operations requiring human approval';
COMMENT ON TABLE chasen_proactive_insights IS 'Stores proactive insights generated by the ChaSen AI system';
COMMENT ON TABLE chasen_user_memories IS 'Stores user preferences and context learned from conversations';
COMMENT ON FUNCTION search_graph_nodes IS 'Semantic search for graph nodes using vector similarity';
COMMENT ON FUNCTION detect_health_drops IS 'Detects significant health score drops over a period';
